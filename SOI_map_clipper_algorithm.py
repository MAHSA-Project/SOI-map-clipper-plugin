# -*- coding: utf-8 -*-

"""
/***************************************************************************
 SoiMapClipper
                                 A QGIS plugin
 This plugin clips the map area of Survey of India map sheets
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-30
        copyright            : (C) 2022 by Jack Tomaney
        email                : jat90@cam.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jack Tomaney'
__date__ = '2022-03-30'
__copyright__ = '(C) 2022 by Jack Tomaney'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import inspect

from qgis.PyQt.QtCore import QCoreApplication, QSettings, QTranslator, QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterString,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterCrs,
                       QgsProject)

from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog

# Import the code for the dialog
import os.path
import math
import pandas as pd
from qgis import processing
import numpy as np
from osgeo import gdal
import tempfile
from qgis.core import Qgis
from qgis.core import (
 QgsRasterLayer,
 QgsProject,
 QgsPointXY,
 QgsRaster,
 QgsRasterShader,
 QgsColorRampShader,
 QgsSingleBandPseudoColorRenderer,
 QgsSingleBandColorDataRenderer,
 QgsSingleBandGrayRenderer,
 QgsVectorLayer,
 QgsField,
 QgsFeature,
 QgsGeometry,
 QgsProcessingUtils,
 QgsProcessing,
 QgsExpression,
 QgsExpressionContext,
 QgsExpressionContextUtils,
 QgsProcessingContext,
 edit,
 )

from qgis.utils import iface
from qgis.analysis import (
    QgsRasterCalculator,
    QgsRasterCalculatorEntry,
)

class SoiMapClipperAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    LINEQUAL = 'LINEQUAL'
    MASK = 'MASK'
    DATA_TYPE = 'DATA_TYPE'
    NODATA = 'NODATA'
    TARGET_CRS = 'TARGET_CRS'

    #Add this in if you want to view different stages of the process in QGIS
    def flags(self):
        return super().flags() | QgsProcessingAlgorithm.FlagNoThreading

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.TYPES = [self.tr('Use Input Layer Data Type'), 'Byte', 'Int16', 'UInt16', 'UInt32', 'Int32', 'Float32',
                      'Float64', 'CInt16', 'CInt32', 'CFloat32', 'CFloat64']
        # Input for features source - raster layer
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                self.tr('Input raster SOI map sheet'),
                [QgsProcessing.TypeRaster]))
        #Target CRS
        self.addParameter(QgsProcessingParameterCrs(self.TARGET_CRS,
                                                    self.tr('Target CRS'),
                                                    optional=True))
        #Input for map quality
        self.addParameter(
            QgsProcessingParameterEnum(
                self.LINEQUAL,
                self.tr('Quality of map area border line (only change to high or low if you are not happy with the result when using medium)'),
                options=[('High'), ('Medium'), ('Low')],
                defaultValue=1,))
        #Input for masking pixels
        self.addParameter(
            QgsProcessingParameterBoolean(self.MASK,
                                          self.tr('Mask area outside map area'),
                                          defaultValue=True))
        #No data value input
        self.addParameter(QgsProcessingParameterNumber(self.NODATA,
                                                       self.tr('Assign a specified nodata value to output bands'),
                                                       type=QgsProcessingParameterNumber.Double,
                                                       defaultValue=None,
                                                       optional=True))
        #Output data type
        dataType_param = QgsProcessingParameterEnum(self.DATA_TYPE,
                                                    self.tr('Output data type'),
                                                    self.TYPES,
                                                    allowMultiple=False,
                                                    defaultValue=0)
        dataType_param.setFlags(dataType_param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(dataType_param)
        # Output features source - a raster geotiff
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT,
                self.tr('Output clipped raster'),
                'GeoTIFF (*.tif *.tiff *.TIF *.TIFF)',
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        rlayer = self.parameterAsRasterLayer(parameters, self.INPUT, context)
        output_path_raster = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        teststring = self.parameterAsString(parameters, self.INPUT, context)
        print(teststring)
        #if feedback.isCanceled():
         #   break
        #(sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
        #        context, source.fields(), source.wkbType(), source.sourceCrs())

        # Compute the number of steps to display within the progress bar and
        # get features from source
        #total = 100.0 / source.featureCount() if source.featureCount() else 0
        #features = source.getFeatures()
        #rlayer = QgsRasterLayer(source)
        # Add to map
        #iface.addRasterLayer(source, "raster test")
        # Check raster data type
        data_provider = rlayer.constDataProvider()

        #Find CRS of raster
        crs = rlayer.crs().authid()
        print(crs)
        if crs != "EPSG:4326":
            rlayerwarp = processing.run('gdal:warpreproject', {'INPUT': rlayer,
                                                            'SOURCE_CRS': crs,
                                                            'TARGET_CRS': 'EPSG:4326',
                                                            'RESAMPLING': 0,
                                                            'DATA_TYPE': 0,
                                                            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
                                                            })['OUTPUT']
            rlayer = QgsRasterLayer(rlayerwarp)


        # Find extent
        huh = rlayer.extent()

        # Find individual coordinates of extent
        xmin = huh.xMinimum()
        xmax = huh.xMaximum()
        ymin = huh.yMinimum()
        ymax = huh.yMaximum()

        # Create a vector layer with extent of raster
        vll = QgsVectorLayer("Polygon", "temp", "memory")

        # Add some attribute data
        pr = vll.dataProvider()
        pr.addAttributes([QgsField("ID", QVariant.Int)
                          ])
        vll.updateFields()

        # Add the polygon to the layer
        f = QgsFeature()

        f.setGeometry(QgsGeometry.fromPolygonXY([[QgsPointXY(xmin, ymin), QgsPointXY(xmin, ymax),
                                                  QgsPointXY(xmax, ymax), QgsPointXY(xmax, ymin)]]))

        f.setAttributes([1])
        pr.addFeature(f)
        vll.updateExtents()

        # Show the layer in QGIS
        #QgsProject.instance().addMapLayer(vll)
        #context.temporaryLayerStore().addMapLayer(vll)
        # take 1 degree off and add one degree on to the extent (to make sure it is covered) and make grid.
        xminfl = math.floor(xmin) - 1
        xmaxfl = math.ceil(xmax) + 1
        yminfl = math.floor(ymin) - 1
        ymaxfl = math.ceil(ymax) + 1

        # Make string of extents
        exin = str(xminfl) + ',' + str(xmaxfl) + ',' + str(yminfl) + ',' + str(ymaxfl)

        # run create grid tool for 0.25 degrees
        grdd = processing.run("native:creategrid", {'TYPE': '2', 'EXTENT': exin, 'HSPACING': '0.25',
                                                    'VSPACING': '0.25', 'HOVERLAY': '0', 'VOVERLAY': '0',
                                                    'CRS': 'EPSG:4326', 'OUTPUT': 'memory:'})
        #QgsProject.instance().addMapLayer(grdd['OUTPUT'])

        # Select those of the grid that intersept the raster
        grddint = processing.run("native:selectbylocation", {'INPUT': grdd['OUTPUT'], 'PREDICATE': '0',
                                                             'INTERSECT': vll, 'METHOD': '0'})

        bufg = processing.run("native:saveselectedfeatures", {'INPUT': grddint['OUTPUT'],
                                                               'OUTPUT': 'memory:'
                                                               })

        #QgsProject.instance().addMapLayer(bufg['OUTPUT'])
        pd.options.mode.chained_assignment = None
        # Change to pandas dataframe
        cols = [f.name() for f in bufg['OUTPUT'].fields()]
        datagen = ([f[col] for col in cols] for f in bufg['OUTPUT'].getFeatures())
        df = pd.DataFrame.from_records(data=datagen, columns=cols)
        df['row_num'] = np.arange(len(df))
        df = df.sort_values(by=['top', 'left'])
        df["order"] = np.arange(len(df))
        # Add column and rown numbers to df
        df["Ycoln"] = 0
        df["Xcoln"] = 0

        for nuu in range(1, len(df)):
            nuu2 = int(df.loc[df['order'] == nuu]['row_num'])
            nuu3 = int(df.loc[df['order'] == nuu - 1]['row_num'])
            if nuu == 0:
                nuu = 0
            elif df.top[nuu2] == df.top[nuu3]:
                df.Ycoln[nuu2] = df.Ycoln[nuu3]
                df.Xcoln[nuu2] = df.Xcoln[nuu3] + 1
            else:
                df.Ycoln[nuu2] = df.Ycoln[nuu3] + 1
                df.Xcoln[nuu2] = 0

        # Number of y and x columns
        numycol = df['Ycoln'].max() + 1
        xgrinum = df['Xcoln'].max() + 1

        # Sort DF back to row number and merge
        df = df.sort_values(by=['row_num'])

        # Merge dataframe order with vector
        layer_provider = bufg['OUTPUT'].dataProvider()
        layer_provider.addAttributes(
            [QgsField("order", QVariant.Int), QgsField("Ycoln", QVariant.Int), QgsField("Xcoln", QVariant.Int)])
        bufg['OUTPUT'].updateFields()

        bufg['OUTPUT'].startEditing()
        idx = bufg['OUTPUT'].fields().indexFromName('order')
        idxYco = bufg['OUTPUT'].fields().indexFromName('Ycoln')
        idxXco = bufg['OUTPUT'].fields().indexFromName('Xcoln')

        features = bufg['OUTPUT'].getFeatures()
        for f in features:
            id = f["id"]
            orrd = df.loc[df['id'] == id].index[0]
            orrd2 = df.iloc[orrd, df.columns.get_loc('order')]
            orrd2Y = df.iloc[orrd, df.columns.get_loc('Ycoln')]
            orrd2X = df.iloc[orrd, df.columns.get_loc('Xcoln')]
            ordd3 = orrd2.item()
            ordd3Y = orrd2Y.item()
            ordd3X = orrd2X.item()
            f[idx] = ordd3
            f[idxYco] = ordd3Y
            f[idxXco] = ordd3X
            bufg['OUTPUT'].updateFeature(f)

        bufg['OUTPUT'].commitChanges()

        # Merge columns if it isnt an even 3x3 grid
        if numycol != 3 or xgrinum != 3:
            yandx = ["Ycoln", "Xcoln"]
            xandy = ["Xcoln", "Ycoln"]
            #
            # Loop for Y and then X
            for xdr in range(len(yandx)):
                # Find sequence of Y columns
                minmaxY = range(df[str(yandx[xdr])].min(), df[yandx[xdr]].max() + 1)
                #
                # Loop for each Y column to merge line by line
                for xdrcol in minmaxY:
                    # Find middle of x colmn to know which cells to merge.
                    middcol = range((df[xandy[xdr]].min() + 1), (df[xandy[xdr]].max() - 1), 1)
                    # Select these from the shapefile
                    exp33 = yandx[xdr] + ' = ' + str(minmaxY[xdrcol]) + ' AND ' + xandy[xdr] + ' >= ' + str(
                        df[xandy[xdr]].min() + 1) + ' AND ' + xandy[xdr] + ' <= ' + str(df[xandy[xdr]].max() - 1)
                    bufgsell = bufg['OUTPUT'].selectByExpression(exp33, QgsVectorLayer.SetSelection)
                    bufgsell_selection = bufg['OUTPUT'].selectedFeatures()
                    # Output these as seperate layer
                    bsel = processing.run("native:saveselectedfeatures", {'INPUT': bufg['OUTPUT'],
                                                                          'OUTPUT': 'memory:'
                                                                          })
                    bselfeat = bsel['OUTPUT'].featureCount()
                    #Only run the next part if there are selected features
                    if bselfeat != 0:
                        # Delete from origonal layer
                        with edit(bufg['OUTPUT']):
                            bufg['OUTPUT'].deleteSelectedFeatures()
                        # Dissolve new layer
                        bseldis = processing.run("native:dissolve", {'INPUT': bsel['OUTPUT'],
                                                                     'OUTPUT': 'memory:'})
                        QgsProject.instance().addMapLayer(bseldis['OUTPUT'])
                        if xdr == 0:
                            idxx = bsel['OUTPUT'].fields().indexFromName('Xcoln')
                            bsmin = bsel['OUTPUT'].minimumValue(idxx)
                            with edit(bseldis['OUTPUT']):
                                bseldis['OUTPUT'].updateFields()
                                for f in bseldis['OUTPUT'].getFeatures():
                                    f['Xcoln'] = bsmin
                                    bseldis['OUTPUT'].updateFeature(f)
                        if xdr == 1:
                            idxxt = bsel['OUTPUT'].fields().indexFromName('top')
                            bsmint = bsel['OUTPUT'].minimumValue(idxxt)
                            with edit(bseldis['OUTPUT']):
                                bseldis['OUTPUT'].updateFields()
                                for f in bseldis['OUTPUT'].getFeatures():
                                    f['top'] = bsmint
                                    bseldis['OUTPUT'].updateFeature(f)
                        #
                        shplist = [bufg['OUTPUT'], bseldis['OUTPUT']]
                        # Merge two back together
                        bufg = processing.run("native:mergevectorlayers", {'LAYERS': shplist, 'OUTPUT': 'memory:'})

        #QgsProject.instance().addMapLayer(bufg['OUTPUT'])

        # Reorder cells
        # Change to pandas dataframe
        cols = [f.name() for f in bufg['OUTPUT'].fields()]
        datagen = ([f[col] for col in cols] for f in bufg['OUTPUT'].getFeatures())
        df = pd.DataFrame.from_records(data=datagen, columns=cols)
        df['row_num'] = np.arange(len(df))
        df = df.sort_values(by=['top', 'left'])
        df["order2"] = np.arange(len(df))

        # Sort DF back to row number and merge
        df = df.sort_values(by=['row_num'])

        # Merge dataframe order with vector
        layer_provider = bufg['OUTPUT'].dataProvider()
        layer_provider.addAttributes([QgsField("order2", QVariant.Int)])

        bufg['OUTPUT'].updateFields()
        print(bufg['OUTPUT'].fields().names())

        bufg['OUTPUT'].startEditing()
        idx = bufg['OUTPUT'].fields().indexFromName('order2')

        features = bufg['OUTPUT'].getFeatures()
        for f in features:
            id = f["id"]
            orrd = df.loc[df['id'] == id].index[0]
            orrd2 = df.iloc[orrd, df.columns.get_loc('order2')]
            ordd3 = orrd2.item()
            f[idx] = ordd3
            bufg['OUTPUT'].updateFeature(f)

        bufg['OUTPUT'].commitChanges()

        # Work out buffer distantce by selecting centre
        bufg['OUTPUT'].selectByExpression('"order2"=\'4\'', QgsVectorLayer.SetSelection)

        centbb = processing.run("native:saveselectedfeatures", {'INPUT': bufg['OUTPUT'],
                                                              'OUTPUT': 'memory:'
                                                              })
        # Work out largest size of the polygon side for the buffer
        # change centbb to lines and then explode
        centbbl = processing.run("native:polygonstolines", {'INPUT': centbb['OUTPUT'],
                                                            'OUTPUT': 'memory:'
                                                            })
        centbble = processing.run("native:explodelines", {'INPUT': centbbl['OUTPUT'],
                                                          'OUTPUT': 'memory:'})
        # Calculate length of lines and find longest
        centbblelength = processing.run("qgis:exportaddgeometrycolumns", {'INPUT': centbble['OUTPUT'],
                                                                          'CALC_METHOD': 0,
                                                                          'OUTPUT': 'memory:'
                                                                          })
        sidx = centbblelength['OUTPUT'].fields().indexFromName('length')
        ssmax = centbblelength['OUTPUT'].maximumValue(sidx)

        # A good buffer to use is roughly 1/80th of the smallest size of the map (this therefore scales for latitude differences and map sheet size differences etc.)
        bufssmal = ssmax / 80

        # Buffer grid
        bufgs = processing.run("native:buffer", {'INPUT': bufg['OUTPUT'], 'DISTANCE': str(bufssmal),
                                                 'END_CAP_STYLE': '1', 'JOIN_STYLE': '1',
                                                 'OUTPUT': 'memory:'})
        print('buffer of ', str(bufssmal))

        # Select cells on edge of map sheet
        frrt = []

        features = bufgs['OUTPUT'].getFeatures()
        for f2 in features:
            if f2['order2'] == 0 or f2['order2'] == 2 or f2['order2'] == 6 or f2['order2'] == 8:
                frrt.append(f2.id())

        bufgs['OUTPUT'].dataProvider().deleteFeatures(frrt)

        # Select overlapping grid square
        # Select centre
        bufgs['OUTPUT'].selectByExpression('"order2"=\'4\'', QgsVectorLayer.SetSelection)

        cent_selection = bufgs['OUTPUT'].selectedFeatures()

        cent = processing.run("native:saveselectedfeatures", {'INPUT': bufgs['OUTPUT'],
                                                              'OUTPUT': 'memory:'
                                                              })

        #QgsProject.instance().addMapLayer(cent['OUTPUT'])

        # What to use as quantile for map
        quanyy = self.parameterAsInt(parameters, self.LINEQUAL, context)
        if quanyy == 2:
            quantty = 20
            lengthrr = 40
            quna = 'Low'
        elif quanyy == 0:
            quantty = 7
            lengthrr = 22
            quna = 'High'
        else:
            quantty = 13
            lengthrr = 28
            quna = 'Medium'

        # Loop for all sides of map sheet
        lpvar = [1, 3, 5, 7]  # Sides of map sheet
        lname = ['bottom', 'left', 'right', 'top']  # Which side?
        lpordco = ['x', 'y', 'y', 'x']  # x or y axis
        xyangll = [90, 180, 180, 90]  # Rough angle lines should be travelling in
        angpoin = [90, 0, 0, 90]  # Angle that points are facing
        ritnum = 0

        for it in range(len(lpvar)):
            #
            ssid = '"order2"=\'' + str(lpvar[it]) + '\''
            #
            # select other
            bufgs['OUTPUT'].selectByExpression(ssid, QgsVectorLayer.SetSelection)
            #
            side = processing.run("native:saveselectedfeatures", {'INPUT': bufgs['OUTPUT'],
                                                                  'OUTPUT': 'memory:'
                                                                  })
            #
            # QgsProject.instance().addMapLayer(side['OUTPUT'])
            #
            # intersect
            intersere = processing.run("native:intersection", {'INPUT': cent['OUTPUT'],
                                                             'OVERLAY': side['OUTPUT'],
                                                             'OUTPUT': 'memory:'
                                                             })['OUTPUT']
            #
            # QgsProject.instance().addMapLayer(intersere['OUTPUT'])
            # If the left side was moved due to not being in the correct place, then move the right too
            if ritnum != 0 and lpordco[it] == 'y':
                # how far has it moved?
                moo = (intersere.extent().xMaximum() - intersere.extent().xMinimum()) * (ritnum + 1)
                # Change x coords
                newxmax = intersere.extent().xMaximum() - moo
                newxmin = intersere.extent().xMinimum() - moo
                newymin = intersere.extent().yMinimum()
                newymax = intersere.extent().yMaximum()
                # Create new polygon
                vll5 = QgsVectorLayer("Polygon", "temp", "memory")
                #
                # Add some attribute data
                prrectt = vll5.dataProvider()
                prrectt.addAttributes([QgsField("ID", QVariant.Int)])
                vll5.updateFields()
                #
                # Add the polygon to the layer
                frectt = QgsFeature()
                #
                # Set extent
                frectt.setGeometry(
                    QgsGeometry.fromPolygonXY([[QgsPointXY(newxmin, newymin), QgsPointXY(newxmin, newymax),
                                                QgsPointXY(newxmax, newymax),
                                                QgsPointXY(newxmax, newymin)]]))
                #
                # Create and load polygon
                frectt.setAttributes([1])
                prrectt.addFeature(frectt)
                vll5.updateExtents()
                #
                QgsProject.instance().addMapLayer(vll5)
                intersere = vll5
            ritnum = 0
            # While loop (incase it is focused on wrong part of raster)
            finfeat = 0
            repnum = 0
            while finfeat == 0:
                # If it is not the first loop calculate new area to look in
                if repnum == 1:
                    ritnum = ritnum + 1
                    # Work out new area for search
                    if lpvar[it] == 3:
                        # Work out new min and max
                        newxmax = intersere.extent().xMinimum()
                        newxmin = intersere.extent().xMinimum() - (
                                    intersere.extent().xMaximum() - intersere.extent().xMinimum())
                        newymin = intersere.extent().yMinimum()
                        newymax = intersere.extent().yMaximum()
                    elif lpvar[it] == 5:
                        # Work out new min and max
                        newxmax = intersere.extent().xMaximum() + (
                                    intersere.extent().xMaximum() - intersere.extent().xMinimum())
                        newxmin = intersere.extent().xMaximum()
                        newymin = intersere.extent().yMinimum()
                        newymax = intersere.extent().yMaximum()
                    #
                    print("hello")
                    # Create new polygon
                    vll4 = QgsVectorLayer("Polygon", "temp", "memory")
                    #
                    # Add some attribute data
                    prrectt = vll4.dataProvider()
                    prrectt.addAttributes([QgsField("ID", QVariant.Int)])
                    vll4.updateFields()
                    #
                    # Add the polygon to the layer
                    frectt = QgsFeature()
                    #
                    # Set extent
                    frectt.setGeometry(
                        QgsGeometry.fromPolygonXY([[QgsPointXY(newxmin, newymin), QgsPointXY(newxmin, newymax),
                                                    QgsPointXY(newxmax, newymax),
                                                    QgsPointXY(newxmax, newymin)]]))
                    #
                    # Create and load polygon
                    frectt.setAttributes([1])
                    prrectt.addFeature(frectt)
                    vll4.updateExtents()
                    #
                    QgsProject.instance().addMapLayer(vll4)
                    intersere = vll4
                repnum = 1
                # Clip raster by intersection
                #
                result = processing.run('gdal:cliprasterbyextent', {'INPUT': rlayer,
                                                                    'PROJWIN': intersere,
                                                                    'DATA_TYPE': 0,
                                                                    'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
                                                                    })['OUTPUT']
                result = QgsRasterLayer(result)
                # New quantiles
                # Random points in extent
                quanpoints = processing.run('native:randompointsinextent', {'EXTENT': intersere,
                                                                            'MAX_ATTEMPTS': 200,
                                                                            'MIN_DISTANCE': 0,
                                                                            'OUTPUT': 'TEMPORARY_OUTPUT',
                                                                            'POINTS_NUMBER': 5000,
                                                                            'TARGET_CRS': vll.crs(),
                                                                            })['OUTPUT']
                # Find pixel values of the points
                quanpointssam = processing.run('native:rastersampling', {'INPUT': quanpoints,
                                                                         'RASTERCOPY': result,
                                                                         'COLUMN_PREFIX': 'BAND_',
                                                                         'OUTPUT': 'TEMPORARY_OUTPUT',
                                                                         })['OUTPUT']
                #
                # band1
                rasba1 = processing.run('gdal:translate', {'COPY_SUBDATASETS': False,
                                                           'DATA_TYPE': 0,
                                                           'EXTRA': '-b 1',
                                                           'INPUT': result,
                                                           'NODATA': None,
                                                           'OPTIONS': '',
                                                           'OUTPUT': 'TEMPORARY_OUTPUT',
                                                           'TARGET_CRS': None})['OUTPUT']
                rasb1result = QgsRasterLayer(rasba1)
                entries = []
                #
                rasb1 = QgsRasterCalculatorEntry()
                rasb1.ref = 'rasout@1'
                rasb1.raster = rasb1result  # rlayer
                rasb1.bandNumber = 1
                entries.append(rasb1)
                # iface.addRasterLayer(rasba1)
                # band2
                rasba2 = processing.run('gdal:translate', {'COPY_SUBDATASETS': False,
                                                           'DATA_TYPE': 0,
                                                           'EXTRA': '-b 2',
                                                           'INPUT': result,
                                                           'NODATA': None,
                                                           'OPTIONS': '',
                                                           'OUTPUT': 'TEMPORARY_OUTPUT',
                                                           'TARGET_CRS': None})['OUTPUT']
                rasb2result = QgsRasterLayer(rasba2)
                rasb2 = QgsRasterCalculatorEntry()
                rasb2.ref = 'rasout@2'
                rasb2.raster = rasb2result  # rlayer
                rasb2.bandNumber = 1  # 2
                entries.append(rasb2)
                # iface.addRasterLayer(rasba2)
                # band3
                rasba3 = processing.run('gdal:translate', {'COPY_SUBDATASETS': False,
                                                           'DATA_TYPE': 0,
                                                           'EXTRA': '-b 3',
                                                           'INPUT': result,
                                                           'NODATA': None,
                                                           'OPTIONS': '',
                                                           'OUTPUT': 'TEMPORARY_OUTPUT',
                                                           'TARGET_CRS': None})['OUTPUT']
                rasb3result = QgsRasterLayer(rasba3)
                rasb3 = QgsRasterCalculatorEntry()
                rasb3.ref = 'rasout@3'
                rasb3.raster = rasb3result  # rlayer
                rasb3.bandNumber = 1  # 3
                entries.append(rasb3)
                # iface.addRasterLayer(rasba3)
                # Add rasters together
                rasbanall = QgsProcessingUtils.generateTempFilename('rasbanall.tif')
                #
                calc = QgsRasterCalculator('rasout@1 + rasout@2 + rasout@3', rasbanall, 'GTiff', result.extent(),
                                           result.width(),
                                           result.height(), entries)
                calc.processCalculation()
                iface.addRasterLayer(rasbanall)
                rasoutall = QgsRasterLayer(rasbanall)
                #
                # Find quantile of the middle section of raster filtering out blank values
                stats = rasoutall.dataProvider().bandStatistics(1, QgsRasterBandStats.All)
                dataquanpoints1 = list(
                    filter(None, [f['BAND_1'] for f in quanpointssam.getFeatures()]))  # List all values in column
                dataquanpoints2 = list(
                    filter(None, [f['BAND_2'] for f in quanpointssam.getFeatures()]))  # List all values in column
                dataquanpoints3 = list(
                    filter(None, [f['BAND_3'] for f in quanpointssam.getFeatures()]))  # List all values in column
                # loop for 10th percentile
                for p in [quantty]:
                    rasbanallquan = round((np.percentile(dataquanpoints1, p)) + (np.percentile(dataquanpoints2, p)) \
                                          + (np.percentile(dataquanpoints3, p)))
                    print(rasbanallquan)
                #
                # Reclassify full raster using the percentile value
                rasoutreclass = processing.run('native:reclassifybytable', {'DATA_TYPE': 0,
                                                                            'INPUT_RASTER': rasoutall,
                                                                            'NODATA_FOR_MISSING': False,
                                                                            'NO_DATA': -9999,
                                                                            'OUTPUT': 'TEMPORARY_OUTPUT',
                                                                            'RANGE_BOUNDARIES': 0,
                                                                            'RASTER_BAND': 1,
                                                                            'TABLE': [stats.minimumValue, rasbanallquan,
                                                                                      '0',
                                                                                      rasbanallquan, stats.maximumValue,
                                                                                      '1'],
                                                                            })['OUTPUT']
                #
                iface.addRasterLayer(rasoutreclass)
                rastest2 = processing.run('gdal:sieve', {'INPUT': rasoutreclass,
                                                         'THRESHOLD:': 40,
                                                         'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT})['OUTPUT']
                iface.addRasterLayer(rastest2)
                # Make a shapefile and vectorise raster
                tpol = QgsProcessingUtils.generateTempFilename('tpollo.shp')
                polre = processing.run('gdal:contour', {'INPUT': rastest2, 'BAND': 1, 'INTERVAL': 1, 'OUTPUT': tpol})[
                    'OUTPUT']
                # polre = processing.run('gdal:polygonize', {'INPUT':rastest, 'BAND':1, 'FIELD':'DN',  'OUTPUT': tpol})['OUTPUT']
                polrev = QgsVectorLayer(polre, 'vec', 'ogr')
                # QgsProject.instance().addMapLayer(polrev)
                #
                # Reproject to 3857
                plinesrep = processing.run("native:reprojectlayer", {'INPUT': polrev,
                                                                     'TARGET_CRS': 'EPSG:3857',
                                                                     'OUTPUT': 'memory:'})
                #
                # QgsProject.instance().addMapLayer(plinesrep['OUTPUT'])
                #
                # Simplify to 20 metres
                plinessimp = processing.run("native:simplifygeometries", {'INPUT': plinesrep['OUTPUT'],
                                                                          'METHOD': '0',
                                                                          'TOLERANCE': '20',
                                                                          'OUTPUT': 'memory:'})
                #
                # QgsProject.instance().addMapLayer(plinessimp['OUTPUT'])
                # Explode the lines
                plinesexpO = processing.run("native:explodelines", {'INPUT': plinessimp['OUTPUT'],
                                                                    'OUTPUT': 'memory:'})
                #
                # QgsProject.instance().addMapLayer(plinesexpO['OUTPUT'])
                # Calculate length of features
                newlength = processing.run("qgis:exportaddgeometrycolumns", {'INPUT': plinesexpO['OUTPUT'],
                                                                             'CALC_METHOD': 2,
                                                                             'OUTPUT': 'memory:'
                                                                             })
                # Find the minimum length a line should be to qualify (starting at 1/27th the lenght of the intersect box)
                interserepl = processing.run("native:polygonstolines", {'INPUT': intersere,
                                                                        'OUTPUT': 'memory:'
                                                                        })
                intersereple = processing.run("native:explodelines", {'INPUT': interserepl['OUTPUT'],
                                                                      'OUTPUT': 'memory:'})
                # Calculate length of lines and find longest
                intersereplelength = processing.run("qgis:exportaddgeometrycolumns", {'INPUT': intersereple['OUTPUT'],
                                                                                      'CALC_METHOD': 2,
                                                                                      'OUTPUT': 'memory:'
                                                                                      })
                insidx = intersereplelength['OUTPUT'].fields().indexFromName('length')
                inssmax = (intersereplelength['OUTPUT'].maximumValue(insidx)) / lengthrr
                #
                # Find absolute minimum length a line should be
                absmin = inssmax / 1.5
                # QgsProject.instance().addMapLayer(newlength['OUTPUT'])
                # Select only features greater than specified length
                lendist = '"length" > ' + str(round(inssmax))
                newlength['OUTPUT'].selectByExpression(lendist, QgsVectorLayer.SetSelection)
                #
                plinesexp_1000_selec = processing.run("native:saveselectedfeatures", {'INPUT': newlength['OUTPUT'],
                                                                                      'OUTPUT': 'memory:'
                                                                                      })
                # There should be at least four lines, so if there is not, lower the maximum length required by 50 untill there are
                numoffeat = plinesexp_1000_selec['OUTPUT'].featureCount()
                qlen = 0
                inssmaxsec = round((inssmax / 25))
                qlenins = inssmax
                while numoffeat < 3 and qlenins > absmin:
                    print(qlenins)
                    qlen = qlen + inssmaxsec
                    qlenins = round(inssmax) - qlen
                    lendist = '"length" > ' + str(qlenins)
                    newlength['OUTPUT'].selectByExpression(lendist, QgsVectorLayer.SetSelection)
                    #
                    plinesexp_1000 = polrev.selectedFeatures()
                    #
                    plinesexp_1000_selec = processing.run("native:saveselectedfeatures", {'INPUT': newlength['OUTPUT'],
                                                                                          'OUTPUT': 'memory:'
                                                                                          })
                    numoffeat = plinesexp_1000_selec['OUTPUT'].featureCount()
                    print('number of features = ', numoffeat)
                #
                # Line should be at least 20% of the length, or they are probably not real
                plinesexp_1000_seleclength = processing.run("qgis:exportaddgeometrycolumns",
                                                            {'INPUT': plinesexp_1000_selec['OUTPUT'],
                                                             'CALC_METHOD': 2,
                                                             'OUTPUT': 'memory:'
                                                             })
                # Sum length of lines
                sumllpl = sum(filter(None, [f['length'] for f in plinesexp_1000_seleclength['OUTPUT'].getFeatures()]))
                # If the sum length of lines is not more than a fifth of the search area then it should not be considered
                if sumllpl < intersereplelength['OUTPUT'].maximumValue(insidx) / 5:
                    finfeat = 0
                    continue
                # QgsProject.instance().addMapLayer(plinesexp_1000_selec['OUTPUT'])
                # Calculate bearing of features
                layer_provider = plinesexp_1000_selec['OUTPUT'].dataProvider()
                layer_provider.addAttributes([QgsField('angle', QVariant.Double)])
                #
                plinesexp_1000_selec['OUTPUT'].updateFields()
                print(plinesexp_1000_selec['OUTPUT'].fields().names())
                #
                expression1 = QgsExpression('degrees(azimuth(start_point($geometry), end_point($geometry)))')
                context = QgsExpressionContext()
                context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(plinesexp_1000_selec['OUTPUT']))
                #
                with edit(plinesexp_1000_selec['OUTPUT']):
                    for f in plinesexp_1000_selec['OUTPUT'].getFeatures():
                        context.setFeature(f)
                        f['angle'] = expression1.evaluate(context)
                        plinesexp_1000_selec['OUTPUT'].updateFeature(f)
                #
                # QgsProject.instance().addMapLayer(plinesexp_1000_selec['OUTPUT'])
                # Select only features that are heading in pretty much the correct direction
                print(xyangll[it])
                angttu = (xyangll[it] + 182)
                angllu = (xyangll[it] + 178)
                if angttu > 360:
                    angttu = angttu - 360
                    angllu = angllu - 360
                    #
                print(angllu)
                angexp = ('"angle" > ' + str((xyangll[it] - 2)) + ' AND "angle" < ' + str((xyangll[it] + 2))
                          + '  OR "angle" > ' + str((xyangll[it] + 178)) + ' AND "angle" < ' + str((xyangll[it] + 182))
                          + ' OR "angle" > ' + str(angllu) + ' AND "angle" < ' + str(angttu))
                #
                plinesexp_1000_selec['OUTPUT'].selectByExpression(angexp, QgsVectorLayer.SetSelection)
                #
                plinesexp_ang = plinesexp_1000_selec['OUTPUT'].selectedFeatures()
                #
                plinesexp_ang_selec = processing.run("native:saveselectedfeatures",
                                                     {'INPUT': plinesexp_1000_selec['OUTPUT'],
                                                      'OUTPUT': 'memory:'
                                                      })
                # QgsProject.instance().addMapLayer(plinesexp_ang_selec['OUTPUT'])
                # How many lines are there in this layer?
                finfeat = plinesexp_ang_selec['OUTPUT'].featureCount()
                if finfeat == 0:
                    continue
                #
                # Generate random points on each line
                randpoint = processing.run("native:randompointsonlines", {'INPUT': plinesexp_ang_selec['OUTPUT'],
                                                                          'POINTS_NUMBER': '5',
                                                                          'OUTPUT': 'memory:'})
                #
                # QgsProject.instance().addMapLayer(randpoint['OUTPUT'])
                #
                # Add coordinates to line
                layer_provider = randpoint['OUTPUT'].dataProvider()
                layer_provider.addAttributes([QgsField('coord', QVariant.Double)])
                #
                randpoint['OUTPUT'].updateFields()
                print(randpoint['OUTPUT'].fields().names())
                #
                xory = '$' + lpordco[it]
                #
                expression1 = QgsExpression(xory)
                context = QgsExpressionContext()
                context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(randpoint['OUTPUT']))
                #
                with edit(randpoint['OUTPUT']):
                    for f in randpoint['OUTPUT'].getFeatures():
                        context.setFeature(f)
                        f['coord'] = round(expression1.evaluate(context), 2)
                        randpoint['OUTPUT'].updateFeature(f)
                #
                # Join points together with line using coordinates
                # First check QGIS version (as it is slightly different between 3.16 and 3.22
                if float(Qgis.QGIS_VERSION[0:4]) < 3.2:
                    ordins = 'ORDER_FIELD'
                    funordins = "qgis:pointstopath"
                else:
                    ordins = 'ORDER_EXPRESSION'
                    funordins = "native:pointstopath"
                #
                linepoi = processing.run(funordins,
                                         {'INPUT': randpoint['OUTPUT'], ordins: 'coord', 'OUTPUT': 'memory:'})
                #
                # QgsProject.instance().addMapLayer(linepoi['OUTPUT'])
                #
                # Simplify by 20 metres
                linepoisimp = processing.run("native:simplifygeometries", {'INPUT': linepoi['OUTPUT'],
                                                                           'METHOD': '0',
                                                                           'TOLERANCE': '20',
                                                                           'OUTPUT': 'memory:'})
                QgsProject.instance().addMapLayer(linepoisimp['OUTPUT'])
                # Extend lines
                linepexte = processing.run("native:extendlines", {'INPUT': linepoisimp['OUTPUT'],
                                                                  'START_DISTANCE': str(
                                                                      intersereplelength['OUTPUT'].maximumValue(
                                                                          insidx)),
                                                                  'END_DISTANCE': str(
                                                                      intersereplelength['OUTPUT'].maximumValue(
                                                                          insidx)),
                                                                  'OUTPUT': 'memory:'})
                # Check angle of points, if too high then rerun simplification.
                angcheck = processing.run("native:extractvertices", {'INPUT': linepexte['OUTPUT'],
                                                                     'OUTPUT': 'memory:'})
                #
                aaan = 0
                tol = 20
                # Change angles if they are around 360
                if lpvar[it] == 3 or lpvar[it] == 5:
                    with edit(angcheck['OUTPUT']):
                        for f in angcheck['OUTPUT'].getFeatures():
                            if f['angle'] > 5:
                                f['angle'] = f['angle'] - 360
                                angcheck['OUTPUT'].updateFeature(f)
                # QgsProject.instance().addMapLayer(angcheck['OUTPUT'])
                idx = angcheck['OUTPUT'].fields().indexFromName('angle')
                maxang = angcheck['OUTPUT'].maximumValue(idx)
                minang = angcheck['OUTPUT'].minimumValue(idx)
                #
                finang = 0
                # While angle of points is less than an amount or more than an amount simplify by more.
                while minang <= angpoin[it] - 5 or maxang >= angpoin[it] + 5:
                    tol = tol * 1.3
                    print(tol)
                    linepoisimp = processing.run("native:simplifygeometries", {'INPUT': linepoi['OUTPUT'],
                                                                               'METHOD': '0',
                                                                               'TOLERANCE': str(tol),
                                                                               'OUTPUT': 'memory:'})
                    linepexte = processing.run("native:extendlines", {'INPUT': linepoisimp['OUTPUT'],
                                                                      'START_DISTANCE': str(
                                                                          intersereplelength['OUTPUT'].maximumValue(
                                                                              insidx)),
                                                                      'END_DISTANCE': str(
                                                                          intersereplelength['OUTPUT'].maximumValue(
                                                                              insidx)),
                                                                      'OUTPUT': 'memory:'})
                    # Check new angles
                    angcheck = processing.run("native:extractvertices", {'INPUT': linepexte['OUTPUT'],
                                                                         'OUTPUT': 'memory:'})
                    # Change angles if they are around 360
                    if lpvar[it] == 3 or lpvar[it] == 5:
                        with edit(angcheck['OUTPUT']):
                            for f in angcheck['OUTPUT'].getFeatures():
                                if f['angle'] > 5:
                                    f['angle'] = f['angle'] - 360
                                    angcheck['OUTPUT'].updateFeature(f)
                    idx = angcheck['OUTPUT'].fields().indexFromName('angle')
                    # Find new min and max
                    maxang = angcheck['OUTPUT'].maximumValue(idx)
                    minang = angcheck['OUTPUT'].minimumValue(idx)
                    # If the points are simlyfied as far as they can go, exit the while loop
                    finang = angcheck['OUTPUT'].featureCount()
                    print(finang)
                    if finang == 2:
                        break
                if minang <= angpoin[it] - 5 or maxang >= angpoin[it] + 5:
                    finfeat = 0
                    continue
                # QgsProject.instance().addMapLayer(linepoisimplength['OUTPUT'])
                # Line before extension should at least be a third of the distance of the map or it is not correct
                linepoisimplength = processing.run("qgis:exportaddgeometrycolumns", {'INPUT': linepoisimp['OUTPUT'],
                                                                                     'CALC_METHOD': 2,
                                                                                     'OUTPUT': 'memory:'
                                                                                     })
                # Sum length of lines
                sumll = sum(filter(None, [f['length'] for f in linepoisimplength['OUTPUT'].getFeatures()]))
                # If the sum length of lines is not more than a third of the search area then it should not be considered
                if sumll < intersereplelength['OUTPUT'].maximumValue(insidx) / 3:
                    finfeat = 0
                    continue
                # QgsProject.instance().addMapLayer(angcheck['OUTPUT'])
                # repeat number if necessary
                repnum = 1
            #
            # If first line
            if it == 0:
                finalline = linepexte['OUTPUT']
            else:  # if other line
                laylis = [finalline, linepexte['OUTPUT']]
                finalline2 = processing.run("native:mergevectorlayers", {'LAYERS': laylis,
                                                                         'OUTPUT': 'memory:'})
                finalline = finalline2['OUTPUT']

        #QgsProject.instance().addMapLayer(finalline)

        # Change line to polygon
        polyout = processing.run("qgis:polygonize", {'INPUT': finalline,
                                                     'OUTPUT': 'memory:'})

        #IF there is a target CRS then set the output CRS to be it
        targetCrs = self.parameterAsCrs(parameters, self.TARGET_CRS, context)
        if targetCrs.isValid():
            crs = targetCrs

            rlayerwarp = processing.run('gdal:warpreproject', {'INPUT': rlayer,
                                                               'SOURCE_CRS': 'EPSG:4326',
                                                               'TARGET_CRS': crs,
                                                               'RESAMPLING': 0,
                                                               'DATA_TYPE': 0,
                                                               'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
                                                               })['OUTPUT']
            rlayer = QgsRasterLayer(rlayerwarp)


        # Convert polygon to 4326
        nativcrs = processing.run("native:reprojectlayer", {'INPUT': polyout['OUTPUT'],
                                                            'TARGET_CRS': crs,
                                                            'OUTPUT': 'memory:'})
        #
        #QgsProject.instance().addMapLayer(nativcrs['OUTPUT'])
        #
        #If there is a target CRS, convert
        #No data value
        if self.NODATA in parameters and parameters[self.NODATA] is not None:
            nodata = self.parameterAsDouble(parameters, self.NODATA, context)
        else:
            nodata = None
        #Which data type
        dtyy = self.parameterAsInt(parameters, self.DATA_TYPE, context)
        #Mask or clip
        BOOLEAN1 = self.parameterAsBool(parameters, self.MASK, context)
        #If true, then clip and mask. Else just clip and not mask
        if BOOLEAN1 == True:
        # Mask and crop map sheet
            result = processing.run('gdal:cliprasterbymasklayer', {'INPUT': rlayer,
                                                                   'MASK': nativcrs['OUTPUT'],
                                                                   'NODATA': nodata,
                                                                   'ALPHA_BAND': False,
                                                                   'CROP_TO_CUTLINE': True,
                                                                   'KEEP_RESOLUTION': False,
                                                                   'DATA_TYPE': dtyy,
                                                                   'OUTPUT': output_path_raster},
                                    is_child_algorithm=True,
                                    context=context,
                                    feedback=feedback
                                    )['OUTPUT']
        else:
            result = processing.run('gdal:cliprasterbyextent', {'INPUT': rlayer,
                                                                   'PROJWIN': nativcrs['OUTPUT'],
                                                                   'DATA_TYPE': dtyy,
                                                                   'OUTPUT': output_path_raster},
                                    is_child_algorithm=True,
                                    context=context,
                                    feedback=feedback
                                    )['OUTPUT']
        #
        try:
           result
        except NameError:
            feedback.pushInfo(self.tr('Not all sides defined. Check if map sheet is correctly georeferenced.'))
        else:
            iface.addRasterLayer(result, "Clipped " + quna)
            iface.messageBar().pushMessage(
                "Success - Your map has been clipped!",
                level=Qgis.Success, duration=3)
        #

        #for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked

            # Add a feature in the sink
        #    sink.addFeature(feature, QgsFeatureSink.FastInsert)

            # Update the progress bar
        #    feedback.setProgress(int(current * total))

        return {self.OUTPUT : result}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'SOI map clipper'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def icon(self):
        cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]
        icon = QIcon(os.path.join(os.path.join(cmd_folder, 'logo.png')))
        return icon

    def createInstance(self):
        return SoiMapClipperAlgorithm()
